# QuizForge Frontend Instructions (Angular v21)

## Technology Stack
- **Framework**: Angular v21.1 (latest stable, use standalone components)
- **Build Tool**: Vite (Angular CLI with Vite builder)
- **Styling**: Tailwind CSS v4.1 + DaisyUI v5.5 (latest)
- **State Management**: We use Angular Signals for local and global state management to ensure high performance on low-resource devices. RxJS is reserved strictly for asynchronous streams, such as API requests and countdown timers. We avoid heavy global state libraries like NgRx to keep the architecture simple.
- **Testing**: Vitest-Angular
- **E2E**: We use Playwright for End-to-End testing. It is configured to run with a single worker to stay within our 2GB RAM limits. Playwright is chosen over Cypress for its superior performance, native mobile emulation, and efficient resource management.
- **HTTP Client**: Angular HttpClient
- **WebSockets**: Socket.IO client v4.7+
- **Fonts**: DynaPuff (headings), Nunito (body)
- Our priority is accessibility for low-end user devices. We use Prerendering (SSG) for all static routes to ensure instant loading without taxing the server. For dynamic routes, we use SSR to offload the heavy rendering logic from the user's device to our Bun server, ensuring the app remains snappy on old hardware.

## Design System: Bubbly Minimalism Implementation

### Core Philosophy
Professional Playground aesthetic: clean/spacious for classrooms, energetic for engagement. NO sharp corners or corporate stiffness.

### DaisyUI Theme Configuration
```typescript
// apps/frontend/src/styles.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: #f9fafb; /* Light gray */
    --primary: #00a5e0;    /* Cyan-blue */
    --secondary: #93c1eb;  /* Light blue-gray */
    --accent: #cd2750;     /* Pink-red for CTAs */
    --text: #070f18;       /* Near-black */
  }
  
  [data-theme="dark"] {
    --background: #040506; /* Dark gray */
    --primary: #1fc3ff;    /* Bright cyan */
    --secondary: #14416c;  /* Dark blue */
    --accent: #d8315b;     /* Bright pink */
    --text: #e7eff8;       /* Light gray-blue */
  }

  body {
    background-color: var(--background);
    color: var(--text);
    font-family: 'Nunito', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  h1, h2, h3, .font-display {
    font-family: 'DynaPuff', cursive;
  }
}
```

### Component Styling Rules
```typescript
// Button Component Example 

// TODO: TEST THEM ALL OUT AND MODIFY?
// Use DaisyUI btn classes extended with Bubbly rules
<button class="btn btn-primary px-6 py-3 rounded-2xl shadow-sm hover:shadow-md hover:scale-105 transition-all duration-150 font-semibold">
  Play Now
</button>

// Card Component
<div class="card bg-secondary rounded-3xl p-6 shadow-lg hover:shadow-xl transition-shadow">
  <div class="card-body">
    <h2 class="card-title font-display text-2xl text-primary">Quiz Title</h2>
  </div>
</div>
```

### Responsive Breakpoints
- **Mobile-first design**: All styles default to mobile, enhance with `sm:`, `md:`, `lg:`
- **Touch targets**: Minimum 44px height/width for all interactive elements
- **Font scaling**: Use `text-base` (16px) minimum for body text, `text-lg` for questions

## Angular Architecture

### Component Hierarchy
// TODO: CHECK THIS OUT BRO
```
apps/frontend/src/app/
├── core/
│   ├── components/        # Singleton components (header, nav, footer)
│   │   └── header.component.ts
│   ├── guards/           # Route guards (auth, game-state)
│   │   └── auth.guard.ts
│   ├── interceptors/     # HTTP interceptors (auth, error)
│   │   └── auth.interceptor.ts
│   ├── services/         # Core singleton services
│   │   ├── auth.service.ts
│   │   ├── websocket.service.ts
│   │   └── api.service.ts
│   └── models/           # Core interfaces used throughout
│       └── user.model.ts
├── features/
│   ├── auth/             # Login, register
│   │   ├── login.component.ts
│   │   └── register.component.ts
│   ├── dashboard/        # Main screen with tabs (Discover, History, etc.)
│   │   ├── dashboard.component.ts
│   │   ├── discover/
│   │   ├── history/
│   │   ├── homework/
│   │   ├── play/
│   │   └── settings/
│   ├── game/
│   │   ├── lobby/        # Game lobby component
│   │   │   └── lobby.component.ts
│   │   ├── question/     # Question display with timer
│   │   │   └── question.component.ts
│   │   ├── scoring/      # Live scoreboard
│   │   │   └── scoring.component.ts
│   │   └── modes/        # Mode-specific UI components
│   │       └── hot-potato/
│   │           └── hot-potato-display.component.ts
│   ├── quiz-builder/     # Create/edit quizzes
│   │   └── builder.component.ts
│   └── history/          # Past games view
│       └── history.component.ts
├── shared/
│   ├── ui/               # Reusable UI components (Bubbly style)
│   │   ├── button/
│   │   │   └── button.component.ts
│   │   ├── card/
│   │   │   └── card.component.ts
│   │   └── timer/
│   │       └── timer.component.ts
│   ├── pipes/            # Custom pipes
│   │   └── capitalize.pipe.ts
│   ├── directives/       # Custom directives
│   │   └── bubbly-hover.directive.ts
│   └── utils/            # Helper functions
│       └── validators.ts
└── app.config.ts         # App-level providers
```

### Module Structure
- **Standalone components only**: Angular v21 default, no NgModules
- **Lazy loading**: Each feature directory is lazy-loaded via routing
- **Core module concept**: Use `providedIn: 'root'` for services, import in `app.config.ts`
- **Shared imports**: Create `shared-imports.ts` for commonly used Angular imports

## Component Design Standards

### Component Anatomy
```typescript
// apps/frontend/src/app/features/game/question/question.component.ts
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { BubblyButtonComponent } from '../../shared/ui/button/button.component';

@Component({
  selector: 'app-question',
  standalone: true,
  imports: [CommonModule, FormsModule, BubblyButtonComponent],
  templateUrl: './question.component.html',
  styleUrls: ['./question.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush // Required for performance
})
export class QuestionComponent {
  @Input({ required: true }) question!: IQuestion;
  @Input() timeRemaining = 0;
  @Output() answerSubmitted = new EventEmitter<string>();
  
  selectedAnswer: string | null = null;
  
  submitAnswer(): void {
    if (this.selectedAnswer) {
      this.answerSubmitted.emit(this.selectedAnswer);
    }
  }
  
  // No business logic, only presentation
}
```

### Template Standards
```html
<!-- question.component.html -->
<div class="card bg-secondary rounded-3xl p-6 shadow-lg max-w-2xl mx-auto">
  <div class="card-body">
    <!-- Question text -->
    <h2 class="card-title font-display text-2xl text-primary mb-4">
      {{ question.text }}
    </h2>
    
    <!-- Timer -->
    <div class="flex items-center justify-center mb-6">
      <span class="text-accent font-display text-3xl">
        {{ timeRemaining }}
      </span>
    </div>
    
    <!-- Answer options -->
    <div class="grid gap-4 mb-6">
      @for (option of question.options; track option.id) {
        <button
          type="button"
          class="btn btn-secondary w-full justify-start px-4 py-3 rounded-2xl hover:bg-primary hover:text-white transition-colors"
          [class.bg-primary]="selectedAnswer === option.id"
          (click)="selectedAnswer = option.id"
        >
          {{ option.text }}
        </button>
      }
    </div>
    
    <!-- Submit button -->
    <div class="card-actions justify-center">
      <app-bubbly-button
        [disabled]="!selectedAnswer"
        (click)="submitAnswer()"
        class="w-full"
      >
        Submit Answer
      </app-bubbly-button>
    </div>
  </div>
</div>
```

### CSS (No SCSS needed with Tailwind)
```css
/* question.component.scss */
/* Keep empty or minimal - use Tailwind classes only */
/* If custom CSS needed, follow Bubbly rules */
```

### Template Best Practices
- **Use `OnPush` change detection** for ALL components
- **Signal inputs** (Angular v21+) over `@Input()` when using Signals
- **TrackBy function** for all `*ngFor` loops
- **Safe navigation operator**: `{{ user?.name }}` for nullable bindings
- **No logic in templates**: Move conditions to component getters
- **Accessibility**: Use `aria-label`, `role`, and semantic HTML

## State Management // TODO: MAKE DECISION

Choose ONE approach below and delete others:

### Option A: Signals (Modern Angular v21+)
```typescript
// apps/frontend/src/app/core/services/game-state.service.ts
import { Injectable, signal, computed } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';

@Injectable({ providedIn: 'root' })
export class GameStateService {
  private readonly state = signal<GameState>(initialState);
  
  // Public readonly signals
  readonly gameState = this.state.asReadonly();
  readonly currentQuestion = computed(() => this.state().currentQuestion);
  readonly leaderboard = computed(() => 
    [...this.state().players].sort((a, b) => b.score - a.score)
  );
  
  // Actions
  updateScore(playerId: string, points: number): void {
    this.state.update(current => ({
      ...current,
      players: current.players.map(p => 
        p.id === playerId ? { ...p, score: p.score + points } : p
      )
    }));
  }
  
  // For template async pipe compatibility
  get gameState$() {
    return toObservable(this.gameState);
  }
}
```

### Option B: RxJS with BehaviorSubject (Familiar)
```typescript
// apps/frontend/src/app/core/services/game-state.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { distinctUntilChanged } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class GameStateService {
  private state = new BehaviorSubject<GameState>(initialState);
  readonly gameState$ = this.state.asObservable();
  
  updateScore(playerId: string, points: number): void {
    const current = this.state.value;
    this.state.next({
      ...current,
      players: current.players.map(p =>
        p.id === playerId ? { ...p, score: p.score + points } : p
      )
    });
  }
}
```

### Option C: NgRx (Enterprise)
```typescript
// State management with NgRx - overkill for 4-person team, avoid unless familiar
// Delete this option
```

## WebSocket Integration

### Socket.IO Client Service
```typescript
// apps/frontend/src/app/core/services/websocket.service.ts
import { Injectable } from '@angular/core';
import { Socket, io } from 'socket.io-client';
import { Observable, Subject, fromEvent } from 'rxjs';
import { environment } from '../../../environments/environment';

@Injectable({ providedIn: 'root' })
export class WebsocketService {
  private socket: Socket;
  private isConnected = false;

  // Event streams
  private questionSubject = new Subject<IQuestion>();
  readonly question$ = this.questionSubject.asObservable();
  
  private scoreUpdateSubject = new Subject<ScoreUpdate>();
  readonly scoreUpdate$ = this.scoreUpdateSubject.asObservable();
  
  constructor() {
    this.socket = io(environment.wsUrl, {
      transports: ['websocket'],
      reconnection: true,
      reconnectionAttempts: 3,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
    });
    
    this.setupListeners();
  }
  
  private setupListeners(): void {
    // Connection events
    this.socket.on('connect', () => {
      this.isConnected = true;
      console.log('Connected to game server');
    });
    
    this.socket.on('disconnect', (reason) => {
      this.isConnected = false;
      console.warn('Disconnected:', reason);
      // Attempt reconnection logic
    });
    
    // Game events
    this.socket.on('question', (question: IQuestion) => {
      this.questionSubject.next(question);
    });
    
    this.socket.on('score-update', (update: ScoreUpdate) => {
      this.scoreUpdateSubject.next(update);
    });
    
    this.socket.on('error', (error: { message: string; code: string }) => {
      console.error('Socket error:', error);
      // TODO: Show user-friendly error notification
    });
  }
  
  // Actions
  joinGame(pin: string, username: string): void {
    this.socket.emit('join-game', { pin, username });
  }
  
  submitAnswer(answer: string, questionId: string): void {
    this.socket.emit('submit-answer', { answer, questionId });
  }
  
  disconnect(): void {
    this.socket.disconnect();
  }
  
  get connectionId(): string | undefined {
    return this.socket.id;
  }
}
```

## API Client

### HttpClient Setup with Tspec
```typescript
// apps/frontend/src/app/core/services/api.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, retry } from 'rxjs/operators';
import { environment } from '../../../environments/environment';
import { CreateQuizRequest, CreateQuizResponse } from '@quizforge/shared-types';

@Injectable({ providedIn: 'root' })
export class ApiService {
  private readonly baseUrl = environment.apiUrl;
  
  constructor(private http: HttpClient) {}
  
  /**
   * Generic GET request with JWT auth
   */
  get<T>(endpoint: string, options?: { headers?: HttpHeaders }): Observable<T> {
    const headers = this.addAuthHeader(options?.headers);
    return this.http.get<T>(`${this.baseUrl}${endpoint}`, { headers }).pipe(
      retry(2), // Retry failed requests twice
      catchError(this.handleError)
    );
  }
  
  /**
   * Generic POST request with JWT auth
   */
  post<T>(endpoint: string, body: unknown, options?: { headers?: HttpHeaders }): Observable<T> {
    const headers = this.addAuthHeader(options?.headers);
    return this.http.post<T>(`${this.baseUrl}${endpoint}`, body, { headers }).pipe(
      catchError(this.handleError)
    );
  }
  
  // Quiz-specific methods (generated from Tspec)
  createQuiz(data: CreateQuizRequest): Observable<CreateQuizResponse> {
    return this.post<CreateQuizResponse>('/api/v1/quizzes', data);
  }
  
  private addAuthHeader(headers?: HttpHeaders): HttpHeaders {
    const token = localStorage.getItem('token');
    if (!headers) {
      headers = new HttpHeaders();
    }
    return token ? headers.set('Authorization', `Bearer ${token}`) : headers;
  }
  
  private handleError(error: HttpErrorResponse): Observable<never> {
    let errorMessage = 'An unknown error occurred';
    
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Client error: ${error.error.message}`;
    } else {
      errorMessage = `Server error: ${error.status} - ${error.message}`;
    }
    
    console.error('API Error:', errorMessage, error);
    
    // TODO: Integrate with global error notification service
    return throwError(() => new Error(errorMessage));
  }
}
```

## Shared Type Imports
```typescript
// Use Nx path mapping in tsconfig.base.json
{
  "compilerOptions": {
    "paths": {
      "@quizforge/shared-types": ["libs/shared/models/src/index.ts"],
      "@quizforge/shared-ui": ["libs/ui-components/src/index.ts"]
    }
  }
}
```

## Testing Standards

### Unit Tests with Jest
```typescript
// apps/frontend/src/app/features/game/question/question.component.spec.ts
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { QuestionComponent } from './question.component';
import { BubblyButtonComponent } from '../../shared/ui/button/button.component';

describe('QuestionComponent', () => {
  let component: QuestionComponent;
  let fixture: ComponentFixture<QuestionComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [QuestionComponent, BubblyButtonComponent]
    }).compileComponents();

    fixture = TestBed.createComponent(QuestionComponent);
    component = fixture.componentInstance;
    
    // Setup required inputs
    component.question = {
      id: 'q1',
      text: 'What is 2+2?',
      options: [
        { id: 'a', text: '3' },
        { id: 'b', text: '4' }
      ],
      correctAnswer: 'b'
    };
    
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should emit answer when submitted', () => {
    jest.spyOn(component.answerSubmitted, 'emit');
    component.selectedAnswer = 'b';
    component.submitAnswer();
    expect(component.answerSubmitted.emit).toHaveBeenCalledWith('b');
  });

  it('should not emit when no answer selected', () => {
    jest.spyOn(component.answerSubmitted, 'emit');
    component.selectedAnswer = null;
    component.submitAnswer();
    expect(component.answerSubmitted.emit).not.toHaveBeenCalled();
  });
});
```

### E2E Tests with Cypress
```typescript
// apps/frontend/tests/e2e/game-flow.cy.ts
describe('Complete Game Flow', () => {
  beforeEach(() => {
    cy.visit('/join');
  });

  it('should join game and answer questions', () => {
    // Join game
    cy.get('[data-cy=pin-input]').type('ABC123');
    cy.get('[data-cy=username-input]').type('TestPlayer');
    cy.get('[data-cy=join-button]').click();
    
    // Verify lobby
    cy.get('[data-cy=lobby-status]').should('contain', 'Waiting for host...');
    
    // Wait for game start (auto-start in test mode)
    cy.get('[data-cy=question-card]', { timeout: 10000 }).should('be.visible');
    
    // Answer first question
    cy.get('[data-cy=answer-option]').first().click();
    cy.get('[data-cy=submit-button]').click();
    
    // Verify score update
    cy.get('[data-cy=score-display]').should('contain', '100');
  });

  it('should handle disconnect and reconnect', () => {
    cy.get('[data-cy=pin-input]').type('ABC123');
    cy.get('[data-cy=username-input]').type('TestPlayer');
    cy.get('[data-cy=join-button]').click();
    
    // Simulate disconnect
    cy.window().then((win) => {
      (win as any).socket.disconnect();
    });
    
    // Should show reconnect button
    cy.get('[data-cy=reconnect-button]').should('exist').click();
    
    // Should reconnect
    cy.get('[data-cy=connection-status]').should('contain', 'Connected');
  });
});
```

## Performance Optimizations

### Angular Performance Checklist
- [ ] **OnPush everywhere**: All components use `ChangeDetectionStrategy.OnPush`
- [ ] **Lazy loading**: All features lazy-loaded via routing
- [ ] **TrackBy**: All `*ngFor` loops have `trackBy` functions
- [ ] **Bundle size**: Keep main bundle <200KB, analyze with `source-map-explorer`
- [ ] **Assets**: Optimize images (WebP format <100KB each), lazy-load heavy assets
- [ ] **SSR**: Angular Universal properly configured (see nx.json)
- [ ] **Tree-shaking**: Only import used icons/functions

### WebSocket Performance
- **Throttle updates**: Score updates throttled to 100ms using RxJS `throttleTime`
- **Binary data**: Use binary frames for large score updates (Socket.IO supports this)
- **Connection pooling**: Single Socket.IO connection per client, shared across services via singleton
- **Disconnect cleanup**: Always unsubscribe in `ngOnDestroy`

```typescript
// In any component using WebSocket
private destroy$ = new Subject<void>();

ngOnDestroy(): void {
  this.destroy$.next();
  this.destroy$.complete();
}

// In template
this.websocket.question$
  .pipe(takeUntil(this.destroy$))
  .subscribe(question => { /* ... */ });
```

## Accessibility (WCAG 2.1 AA)

### Requirements
- **Keyboard navigation**: All interactive elements focusable and operable (Tab order logical)
- **Screen readers**: Use `aria-label`, `aria-live="polite"` for dynamic score updates
- **Color contrast**: All text meets 4.5:1 ratio (DaisyUI themes are pre-configured)
- **Focus indicators**: Visible focus rings on all interactive elements (`focus:ring-2 focus:ring-primary`)
- **Motion**: Respect `prefers-reduced-motion` (disable hover scale animations)

### Implementation Examples
```html
<!-- Question card with ARIA -->
<div class="card" role="region" aria-label="Current question">
  <h2 class="font-display text-2xl text-primary">{{ question.text }}</h2>
  
  <!-- Live region for screen readers -->
  <div aria-live="polite" class="sr-only">
    Time remaining: {{ timeRemaining }} seconds
  </div>
</div>

<!-- Bubbly button with full accessibility -->
<button
  class="btn btn-primary rounded-2xl px-6 py-3 hover:scale-105 transition-transform"
  [disabled]="!selectedAnswer"
  aria-label="Submit your answer"
  (click)="submitAnswer()"
  (keydown.enter)="submitAnswer()"
>
  Submit Answer
</button>
```

## Fonts & Assets

### Google Fonts Import
```html
<!-- apps/frontend/src/index.html -->
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DynaPuff:wght@400;700&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
</head>
```

### Icon Library (Lucide)
```typescript
// Install: npm install lucide-angular
// apps/frontend/src/app/shared/ui/icon/icon.component.ts
import { Component, Input } from '@angular/core';
import { LucideAngularModule } from 'lucide-angular';
import { Icon } from 'lucide-angular/icons';

@Component({
  selector: 'app-icon',
  standalone: true,
  imports: [LucideAngularModule],
  template: `<lucide-icon [name]="name" [size]="size" [class]="class"></lucide-icon>`
})
export class IconComponent {
  @Input() name!: Icon;
  @Input() size = 24;
  @Input() class = '';
}
```

## Common Pitfalls to Avoid
- ❌ **Don't** use `ChangeDetectionStrategy.Default` (always OnPush)
- ❌ **Don't** subscribe in components without `takeUntil` or `async` pipe
- ❌ **Don't** put business logic in templates
- ❌ **Don't** use relative imports (use Nx path mapping)
- ❌ **Don't** commit environment files
- ❌ **Don't** ignore accessibility (test with screen readers)
- ✅ **Do** test on actual low-end devices
- ✅ **Do** use Angular DevTools for performance profiling
- ✅ **Do** keep components small (<200 lines)
- ✅ **Do** use trackBy for all lists
- ✅ **Do** handle WebSocket disconnections gracefully

## TODO: Frontend Unknowns
- [ ] State management library decision (Signals vs NgRx)
- [ ] Specific competitive modes UI components (waiting for mode selection)
- [ ] Internationalization library (i18n) - Angular built-in or Transloco?
- [ ] PWA features (service worker, offline support, app manifest)
- [ ] Error boundary component for production error handling
- [ ] Loading skeleton components for all major views
- [ ] Toast/notification system for user feedback
- [ ] Modal/dialog system for overlays