# QuizForge Backend Instructions (Bun + Express + PostgreSQL)

## Technology Stack
- **Runtime**: Bun v1.3.8+ (latest stable)
- **Framework**: Express v5.2.1+
- **Database**: PostgreSQL v14 (via Supabase)
- **ORM/Query Builder**: // TODO: Confirm choice (see below)
- **WebSockets**: Socket.IO v4.7+
- **Testing**: Bun Test Runner (built-in, no config needed)
- **API Documentation**: Tspec v1.0+ (code-first Swagger)
- **Validation**: Zod v3.22+ for runtime type safety
- **Authentication**: JWT (jsonwebtoken for Bun)
- **Environment**: `.env` file with `POSTGRES_URL`, `JWT_SECRET`, `PORT`

## Project Structure
```
apps/backend/
├── src/
│   ├── api/
│   │   ├── middleware/     # Auth, error handling, validation, rate limiting
│   │   │   ├── auth.ts
│   │   │   ├── error-handler.ts
│   │   │   ├── rate-limiter.ts
│   │   │   └── validation.ts
│   │   ├── controllers/    # Route handlers (1 file per resource)
│   │   │   ├── quiz.controller.ts
│   │   │   ├── session.controller.ts
│   │   │   └── user.controller.ts
│   │   ├── routes/         # Route definitions
│   │   │   ├── index.ts
│   │   │   ├── quiz.routes.ts
│   │   │   └── session.routes.ts
│   │   ├── services/       # Business logic (pure functions)
│   │   │   ├── scoring.service.ts
│   │   │   └── game-mode.service.ts
│   │   └── dtos/           # Zod validation schemas
│   │       ├── quiz.dto.ts
│   │       └── session.dto.ts
│   ├── game/
│   │   ├── modes/          # Competitive mode implementations
│   │   │   ├── hot-potato.engine.ts
│   │   │   ├── double-agent.engine.ts
│   │   │   └── king-of-hill.engine.ts
│   │   ├── engine/         # Core game loop logic
│   │   │   ├── game-session.ts
│   │   │   └── game-state.ts
│   │   └── utils/          # Game-specific helpers
│   │       └── leaderboard.ts
│   ├── database/
│   │   ├── repositories/   # Type-safe data access (1 per entity)
│   │   │   ├── quiz.repository.ts
│   │   │   ├── session.repository.ts
│   │   │   └── user.repository.ts
│   │   └── unit.ts         # Unit of Work transaction management
│   ├── websocket/
│   │   ├── handlers/       # Socket.IO event handlers
│   │   │   ├── game.handler.ts
│   │   │   ├── lobby.handler.ts
│   │   │   └── player.handler.ts
│   │   ├── rooms.ts        # Room management logic
│   │   └── validation.ts   # Socket message validation (Zod)
│   ├── config/
│   │   ├── environment.ts  # Environment validation
│   │   ├── logger.ts       # Structured logging
│   │   └── database.ts     # Database connection pool
│   ├── shared/
│   │   ├── types.ts        # Shared type definitions
│   │   └── constants.ts    # Backend constants
│   ├── app.ts              # Express app factory
│   └── server.ts           # Server entry point
├── tests/
│   ├── unit/               # Unit tests (mirror src structure)
│   ├── integration/        # Integration tests
│   └── fixtures/           # Test data fixtures
├── .env.example
├── package.json
├── tsconfig.json
├── biome.json              # Bun formatter/linter config
└── supabase/
    ├── migrations/         # SQL migration files
    └── seed.sql            # Initial test data
```

## Database Layer

### Unit of Work Pattern Implementation
```typescript
// apps/backend/src/database/unit.ts
import { Database } from 'bun:postgres';
import { drizzle } from 'drizzle-orm/bun-postgres'; // TODO: Choose ORM (see below)

export class Unit {
  private readonly db: Database;
  private completed: boolean;

  constructor(public readonly readOnly: boolean) {
    this.completed = false;
    this.db = new Database(process.env.POSTGRES_URL!);
    
    if (!this.readOnly) {
      this.db.exec('BEGIN TRANSACTION');
    }
  }

  /**
   * Prepare a typed SQL statement with parameters
   * @param sqlQuery - SQL query with $param syntax
   * @param bindings - Parameter object
   * @returns Statement that can be executed
   */
  public prepare<TParams extends Record<string, unknown>, TResult>(
    sqlQuery: string,
    bindings?: TParams
  ): PreparedStatement<TResult> {
    const stmt = this.db.prepare<TResult>(sqlQuery);
    
    if (bindings) {
      // Bind parameters safely
      Object.entries(bindings).forEach(([key, value]) => {
        // Implementation depends on chosen ORM/driver
      });
    }
    
    return {
      get: () => stmt.get(bindings || {}),
      all: () => stmt.all(bindings || {}),
      run: () => stmt.run(bindings || {}),
    };
  }

  /**
   * Get last inserted row ID
   */
  public getLastRowId(): number {
    const result = this.db.prepare<{ id: number }>("SELECT lastval() as id").get();
    if (!result) {
      throw new Error('Unable to retrieve last inserted row id');
    }
    return result.id;
  }

  /**
   * Complete transaction - CRITICAL: Always use try/finally
   * @param commit - true=commit, false=rollback, null=read-only
   */
  public complete(commit: boolean | null = null): void {
    if (this.completed) {
      console.warn('Unit already completed - potential bug');
      return;
    }
    this.completed = true;

    if (commit !== null) {
      this.db.exec(commit ? 'COMMIT' : 'ROLLBACK');
    } else if (!this.readOnly) {
      throw new Error('Transaction opened but commit/rollback not specified. FIX THIS BUG!');
    }

    // CRITICAL: Return connection to pool
    this.db.end();
  }
}

/**
 * Safe wrapper for transaction execution
 * Usage: await withUnit(false, async (unit) => { ... })
 */
export async function withUnit<T>(
  readOnly: boolean,
  operation: (unit: Unit) => Promise<T>
): Promise<T> {
  const unit = new Unit(readOnly);
  try {
    const result = await operation(unit);
    unit.complete(true);
    return result;
  } catch (error) {
    unit.complete(false);
    throw error;
  } finally {
    if (!unit.completed) {
      console.error('Unit not completed - connection leak detected');
      unit.complete(false);
    }
  }
}

interface PreparedStatement<T> {
  get(): T | undefined;
  all(): T[];
  run(): { changes: number; lastInsertRowid: number };
}
```

### Repository Pattern Implementation
```typescript
// apps/backend/src/database/repositories/quiz.repository.ts
import { Unit } from '../unit';
import { IQuiz } from '../../../shared/types';

export class QuizRepository {
  constructor(private readonly unit: Unit) {}

  async findById(id: string): Promise<IQuiz | null> {
    const result = await this.unit.prepare<{ id: string; title: string; description: string }>(`
      SELECT id, title, description 
      FROM quizzes 
      WHERE id = $id
    `).get({ id });

    return result ? {
      id: result.id,
      title: result.title,
      description: result.description,
      questions: [], // TODO: Join questions or fetch separately
    } : null;
  }

  async create(quiz: Omit<IQuiz, 'id' | 'createdAt'>): Promise<string> {
    const result = await this.unit.prepare<{ id: string }>(`
      INSERT INTO quizzes (title, description, creator_id)
      VALUES ($title, $description, $creatorId)
      RETURNING id
    `).run({
      title: quiz.title,
      description: quiz.description,
      creatorId: quiz.creatorId,
    });

    return this.unit.getLastRowId().toString();
  }
}
```

## Express App Configuration

### Application Factory Pattern
```typescript
// apps/backend/src/app.ts
import express, { Application, json, urlencoded } from 'express';
import { Server } from 'socket.io';
import { createServer } from 'http';
import cors from 'cors';
import { config } from './config/environment';
import { errorHandler } from './api/middleware/error-handler';
import { requestLogger } from './api/middleware/request-logger';
import { rateLimiter } from './api/middleware/rate-limiter';
import { authMiddleware } from './api/middleware/auth';
import { registerRoutes } from './api/routes';
import { registerSocketHandlers } from './websocket/handlers';
import { logger } from './config/logger';

export function createApp(): { app: Application; server: Server; io: Server } {
  const app = express();
  const server = createServer(app);
  const io = new Server(server, {
    cors: {
      origin: config.frontendUrl,
      methods: ['GET', 'POST'],
      credentials: true,
    },
    allowEIO3: true,
    pingTimeout: 60000, // 60s ping timeout
    pingInterval: 25000, // 25s ping interval
  });

  // Global middleware
  app.use(json({ limit: '10mb' }));
  app.use(urlencoded({ extended: true }));
  app.use(requestLogger);
  app.use(rateLimiter);
  app.use(cors({ origin: config.frontendUrl, credentials: true }));

  // Health check
  app.get('/health', (req, res) => res.json({ status: 'ok', timestamp: Date.now() }));
  
  // Protected routes
  app.use('/api/v1', authMiddleware, registerRoutes());

  // Global error handling (MUST be last)
  app.use(errorHandler);

  // WebSocket handlers
  registerSocketHandlers(io);

  return { app, server, io };
}
```

## Tspec API Documentation (Code-First)

### Define DTOs with Zod
```typescript
// apps/backend/src/api/dtos/quiz.dto.ts
import { z } from 'zod';

export const QuestionSchema = z.object({
  text: z.string().min(1).max(500),
  type: z.enum(['multiple-choice', 'true-false', 'open']),
  options: z.array(z.object({
    id: z.string(),
    text: z.string(),
  })).optional(),
  correctAnswer: z.string(),
});

export const CreateQuizRequestSchema = z.object({
  title: z.string().min(1).max(200),
  description: z.string().max(1000).optional(),
  questions: z.array(QuestionSchema).min(1).max(100),
});

export type CreateQuizRequest = z.infer<typeof CreateQuizRequestSchema>;

export const CreateQuizResponseSchema = z.object({
  quizId: z.string().uuid(),
  shareCode: z.string().length(8),
});

export type CreateQuizResponse = z.infer<typeof CreateQuizResponseSchema>;
```

### Controller with Tspec
```typescript
// apps/backend/src/api/controllers/quiz.controller.ts
import { Request, Response } from 'express';
import type { Tspec } from 'tspec';
import { CreateQuizRequestSchema, CreateQuizResponseSchema } from '../dtos/quiz.dto';
import { withUnit } from '../../database/unit';
import { authMiddleware } from '../middleware/auth';
import { logger } from '../../config/logger';

export class QuizController {
  /**
   * @tag quiz
   * @summary Create a new quiz
   * @post /api/v1/quizzes
   * @security JWT
   * @example body {
   *   "title": "Science Quiz",
   *   "description": "Basic science questions",
   *   "questions": [...]
   * }
   */
  async create(req: Request, res: Response): Promise<void> {
    // Validate input
    const parseResult = CreateQuizRequestSchema.safeParse(req.body);
    if (!parseResult.success) {
      res.status(400).json({
        error: 'Invalid input',
        code: 'VALIDATION_ERROR',
        details: parseResult.error.errors,
      });
      return;
    }

    const userId = req.user!.id;

    try {
      const quizId = await withUnit(false, async (unit) => {
        const result = await unit.prepare<{ id: string }>(`
          INSERT INTO quizzes (title, description, creator_id)
          VALUES ($title, $description, $creatorId)
          RETURNING id
        `).run({
          title: parseResult.data.title,
          description: parseResult.data.description,
          creatorId: userId,
        });

        const newQuizId = unit.getLastRowId().toString();

        // Insert questions
        for (const q of parseResult.data.questions) {
          await unit.prepare(`
            INSERT INTO questions (quiz_id, text, type, options, correct_answer)
            VALUES ($quizId, $text, $type, $options, $correctAnswer)
          `).run({
            quizId: newQuizId,
            text: q.text,
            type: q.type,
            options: JSON.stringify(q.options),
            correctAnswer: q.correctAnswer,
          });
        }

        return newQuizId;
      });

      logger.info('Quiz created', { quizId, userId });
      
      res.status(201).json({
        quizId,
        shareCode: this.generateShareCode(), // TODO: Implement
      });
    } catch (error) {
      logger.error('Failed to create quiz', error as Error, { userId });
      res.status(500).json({
        error: 'Failed to create quiz',
        code: 'CREATE_FAILED',
      });
    }
  }

  private generateShareCode(): string {
    return Math.random().toString(36).substr(2, 8).toUpperCase();
  }
}
```

### Generate Swagger
```bash
# Add to package.json scripts
"generate:api-docs": "tspec-to-swagger src/api/controllers/*.ts > dist/swagger.json"
```

## WebSocket Protocol

### Event Standards
```typescript
// apps/backend/src/shared/socket-events.ts
export interface ServerToClientEvents {
  'question': (question: IQuestion) => void;
  'score-update': (update: ScoreUpdate) => void;
  'player-joined': (player: PlayerInfo) => void;
  'player-left': (playerId: string) => void;
  'game-state': (state: GameState) => void;
  'error': (error: { message: string; code: string }) => void;
  'game-ended': (results: GameResults) => void;
}

export interface ClientToServerEvents {
  'join-game': (data: { pin: string; username: string }) => void;
  'submit-answer': (data: { answer: string; questionId: string }) => void;
  'leave-game': () => void;
  'request-hint': (data: { questionId: string }) => void;
}

// Validation schemas
import { z } from 'zod';

export const JoinGameSchema = z.object({
  pin: z.string().length(6).regex(/^[A-Z0-9]+$/),
  username: z.string().min(1).max(20).regex(/^[a-zA-Z0-9_-]+$/),
});

export const SubmitAnswerSchema = z.object({
  answer: z.string(),
  questionId: z.string().uuid(),
});
```

### Socket.IO Handlers
```typescript
// apps/backend/src/websocket/handlers/game.handler.ts
import { Server, Socket } from 'socket.io';
import { validateMessage } from '../validation';
import { JoinGameSchema, SubmitAnswerSchema } from '../../shared/socket-events';
import { withUnit } from '../../database/unit';
import { logger } from '../../config/logger';

export function registerGameHandlers(io: Server, socket: Socket): void {
  socket.on('join-game', async (data) => {
    try {
      // Validate message format
      const validated = validateMessage(JoinGameSchema, data);
      
      // Check if session exists
      const session = await withUnit(true, async (unit) => {
        return await unit.prepare(`
          SELECT * FROM sessions WHERE pin = $pin AND status = 'waiting'
        `).get({ pin: validated.pin });
      });

      if (!session) {
        socket.emit('error', { message: 'Session not found', code: 'SESSION_NOT_FOUND' });
        return;
      }

      // Check username uniqueness
      const existing = await withUnit(true, async (unit) => {
        return await unit.prepare(`
          SELECT COUNT(*) as count FROM session_players 
          WHERE session_id = $sessionId AND username = $username
        `).get({ sessionId: session.id, username: validated.username });
      });

      if (existing.count > 0) {
        socket.emit('error', { message: 'Name already taken', code: 'USERNAME_TAKEN' });
        return;
      }

      // Add player to session
      await withUnit(false, async (unit) => {
        await unit.prepare(`
          INSERT INTO session_players (session_id, username, socket_id)
          VALUES ($sessionId, $username, $socketId)
        `).run({
          sessionId: session.id,
          username: validated.username,
          socketId: socket.id,
        });
      });

      // Join Socket.IO room
      socket.join(validated.pin);
      
      // Notify other players
      socket.to(validated.pin).emit('player-joined', {
        id: socket.id,
        username: validated.username,
        score: 0,
      });

      // Send current state to new player
      const players = await withUnit(true, async (unit) => {
        return await unit.prepare(`
          SELECT socket_id as id, username, score 
          FROM session_players 
          WHERE session_id = $sessionId
        `).all({ sessionId: session.id });
      });

      socket.emit('game-state', {
        status: session.status,
        players,
      });

      logger.game('Player joined', { pin: validated.pin, username: validated.username });
    } catch (error) {
      logger.error('Join game error', error as Error, { socketId: socket.id });
      socket.emit('error', { message: 'Failed to join game', code: 'JOIN_ERROR' });
    }
  });

  socket.on('submit-answer', async (data) => {
    try {
      const validated = validateMessage(SubmitAnswerSchema, data);
      
      // TODO: Implement answer validation and scoring
      // This should be delegated to game mode engine
      
    } catch (error) {
      socket.emit('error', { message: 'Invalid answer format', code: 'INVALID_ANSWER' });
    }
  });
}
```

## Testing Standards

### Bun Test Runner Setup
```typescript
// apps/backend/src/tests/setup.ts
import { Database } from 'bun:postgres';

// Setup test database connection
export const testDb = new Database(process.env.TEST_POSTGRES_URL!);

// Cleanup after all tests
export async function cleanupDatabase(): Promise<void> {
  await testDb.exec('TRUNCATE sessions, session_players, quizzes, questions CASCADE');
}

// Mock logger for tests
export const mockLogger = {
  info: jest.fn(),
  warn: jest.fn(),
  error: jest.fn(),
  game: jest.fn(),
};
```

### Unit Tests
```typescript
// apps/backend/src/tests/unit/repositories/quiz.repository.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'bun:test';
import { QuizRepository } from '../../../src/database/repositories/quiz.repository';
import { Unit } from '../../../src/database/unit';
import { withUnit } from '../../../src/database/unit';
import { cleanupDatabase } from '../setup';

describe('QuizRepository', () => {
  beforeEach(async () => {
    await cleanupDatabase();
  });

  it('should create and retrieve a quiz', async () => {
    const quizId = await withUnit(false, async (unit) => {
      const repo = new QuizRepository(unit);
      return await repo.create({
        title: 'Test Quiz',
        description: 'Test description',
        creatorId: 'user-123',
        questions: [],
      });
    });

    const quiz = await withUnit(true, async (unit) => {
      const repo = new QuizRepository(unit);
      return await repo.findById(quizId);
    });

    expect(quiz).not.toBeNull();
    expect(quiz!.title).toBe('Test Quiz');
  });

  it('should return null for non-existent quiz', async () => {
    const result = await withUnit(true, async (unit) => {
      const repo = new QuizRepository(unit);
      return await repo.findById('non-existent');
    });

    expect(result).toBeNull();
  });

  it('should handle database errors gracefully', async () => {
    await expect(async () => {
      await withUnit(false, async () => {
        // Force error by using invalid SQL
        throw new Error('Simulated DB error');
      });
    }).toThrow();
  });
});
```

### Integration Tests
```typescript
// apps/backend/src/tests/integration/game-flow.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'bun:test';
import { createApp } from '../../../src/app';
import { Server } from 'http';
import { io as Client } from 'socket.io-client';

describe('Game Flow Integration', () => {
  let server: Server;
  let baseUrl: string;

  beforeAll(async () => {
    const { server: srv, app } = createApp();
    server = srv;
    baseUrl = 'http://localhost:3001';
    server.listen(3001);
  });

  afterAll(async () => {
    server.close();
  });

  it('should complete full game session', async () => {
    // 1. Host creates quiz
    const createResponse = await fetch(`${baseUrl}/api/v1/quizzes`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${testToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        title: 'Integration Test Quiz',
        questions: [
          {
            text: 'What is 2+2?',
            type: 'multiple-choice',
            options: [{ id: 'a', text: '3' }, { id: 'b', text: '4' }],
            correctAnswer: 'b',
          },
        ],
      }),
    });

    expect(createResponse.ok).toBe(true);
    const { quizId } = await createResponse.json();

    // 2. Host creates session
    const sessionResponse = await fetch(`${baseUrl}/api/v1/sessions`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${testToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ quizId }),
    });

    expect(sessionResponse.ok).toBe(true);
    const { pin } = await sessionResponse.json();
    expect(pin).toHaveLength(6);

    // 3. Player joins via WebSocket
    const playerSocket = Client(baseUrl, { transports: ['websocket'] });
    
    const joinPromise = new Promise<void>((resolve) => {
      playerSocket.emit('join-game', { pin, username: 'TestPlayer' }, (response: any) => {
        expect(response.success).toBe(true);
        resolve();
      });
    });

    await joinPromise;

    // 4. Host starts game
    const hostSocket = Client(baseUrl, { transports: ['websocket'] });
    hostSocket.emit('start-game', { pin });

    // 5. Player receives question
    const questionPromise = new Promise<void>((resolve) => {
      playerSocket.once('question', (question: any) => {
        expect(question.text).toBe('What is 2+2?');
        resolve();
      });
    });

    await questionPromise;

    // Cleanup
    playerSocket.disconnect();
    hostSocket.disconnect();
  });
});
```

## Performance & Scalability

### Database Connection Pooling
```typescript
// apps/backend/src/config/database.ts
import { Database } from 'bun:postgres';

export const pool = new Database(process.env.POSTGRES_URL!, {
  max: 20,                // Max connections in pool
  idleTimeout: 30,        // Close idle connections after 30s
  connectionTimeout: 5,   // Wait max 5s for connection
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, closing database connections');
  await pool.end();
  process.exit(0);
});
```

### Rate Limiting
```typescript
// apps/backend/src/api/middleware/rate-limiter.ts
import { rateLimit } from 'express-rate-limit';
import { logger } from '../../config/logger';

export const rateLimiter = rateLimit({
  store: new (require('rate-limit-bun-store'))(), // TODO: Choose store (memory, Redis)
  windowMs: 60 * 1000, // 1 minute
  max: 60, // 60 requests per IP per minute
  standardHeaders: true,
  legacyHeaders: false,
  skip: (req) => req.path === '/health',
  handler: (req, res) => {
    logger.warn('Rate limit exceeded', { ip: req.ip, path: req.path });
    res.status(429).json({ 
      error: 'Too many requests', 
      code: 'RATE_LIMIT_EXCEEDED',
      retryAfter: Math.ceil(req.rateLimit.resetTime / 1000),
    });
  }
});

// WebSocket rate limiter
export function wsRateLimiter(socket: any, next: Function): void {
  const clientId = socket.handshake.headers['x-forwarded-for'] || socket.handshake.address;
  // TODO: Implement per-client event rate limiting
  next();
}
```

### Memory Management for Game Sessions
```typescript
// apps/backend/src/game/engine/session-manager.ts
export class SessionManager {
  private static sessions = new Map<string, GameSession>();
  private static readonly MAX_SESSION_AGE = 1000 * 60 * 60 * 2; // 2 hours
  private static readonly MAX_SESSIONS = 1000; // Memory limit
  
  /**
   * Get or create session
   */
  static getOrCreate(pin: string): GameSession {
    let session = this.sessions.get(pin);
    
    if (!session) {
      if (this.sessions.size >= this.MAX_SESSIONS) {
        this.cleanupOldestSession();
      }
      
      session = new GameSession(pin);
      this.sessions.set(pin, session);
    }
    
    return session;
  }
  
  /**
   * Cleanup expired sessions every 5 minutes
   */
  static startCleanupInterval(): void {
    setInterval(() => {
      const now = Date.now();
      let cleaned = 0;
      
      for (const [pin, session] of this.sessions.entries()) {
        if (now - session.lastActivity > this.MAX_SESSION_AGE) {
          this.sessions.delete(pin);
          cleaned++;
        }
      }
      
      if (cleaned > 0) {
        logger.info('Cleaned up expired sessions', { cleaned, remaining: this.sessions.size });
      }
    }, 5 * 60 * 1000);
  }
  
  private static cleanupOldestSession(): void {
    let oldest: { pin: string; time: number } | null = null;
    
    for (const [pin, session] of this.sessions.entries()) {
      if (!oldest || session.lastActivity < oldest.time) {
        oldest = { pin, time: session.lastActivity };
      }
    }
    
    if (oldest) {
      this.sessions.delete(oldest.pin);
    }
  }
}
```

## Security Best Practices

### JWT Authentication (Header-Based)
```typescript
// apps/backend/src/api/middleware/auth.ts
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';
import { logger } from '../../config/logger';

export interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: 'host' | 'player';
  };
}

export function authMiddleware(req: AuthenticatedRequest, res: Response, next: NextFunction): void {
  const authHeader = req.headers.authorization;
  
  if (!authHeader?.startsWith('Bearer ')) {
    res.status(401).json({ error: 'Missing or invalid token', code: 'UNAUTHORIZED' });
    return;
  }
  
  const token = authHeader.substring(7);
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { id: string; email: string };
    req.user = { id: decoded.id, email: decoded.email, role: 'host' };
    next();
  } catch (error) {
    logger.warn('JWT verification failed', { error: (error as Error).message, ip: req.ip });
    res.status(401).json({ error: 'Invalid token', code: 'INVALID_TOKEN' });
  }
}
```

### WebSocket Authentication
```typescript
// apps/backend/src/websocket/handlers/auth.ts
export function authenticateSocket(socket: Socket, next: (err?: Error) => void): void {
  const token = socket.handshake.auth.token;
  
  if (!token) {
    return next(new Error('Authentication error: No token provided'));
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!);
    socket.data.user = decoded;
    next();
  } catch (error) {
    next(new Error('Authentication error: Invalid token'));
  }
}

// Usage in app.ts
io.use(authenticateSocket);
```

### SQL Injection Prevention
```typescript
// ✅ CORRECT - Always use Unit.prepare() with parameters
const user = await unit.prepare<IUser>(
  'SELECT * FROM users WHERE id = $id'
).get({ id: userId });

// ❌ WRONG - Never use string concatenation or template literals
const user = await unit.query(`SELECT * FROM users WHERE id = '${userId}'`); // VULNERABLE!
```

## Supabase & Migrations

### Migration Workflow
```bash
# Create new migration
bunx supabase migration new create_quizzes_table

# Reset local db and apply all migrations
bunx supabase db reset

# Generate TypeScript types from DB schema
bunx supabase gen types typescript --local > libs/shared-types/src/database.types.ts

# Push migrations to remote (when ready)
bunx supabase db push
```

### Example Migration
```sql
-- apps/supabase/migrations/20240115120000_create_quizzes_table.sql
CREATE TABLE quizzes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL CHECK (length(title) > 0 AND length(title) <= 200),
  description TEXT CHECK (length(description) <= 1000),
  creator_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for faster lookups
CREATE INDEX idx_quizzes_creator_id ON quizzes(creator_id);
CREATE INDEX idx_quizzes_created_at ON quizzes(created_at DESC);

-- Row Level Security (RLS) - Enable
ALTER TABLE quizzes ENABLE ROW LEVEL SECURITY;

-- Policy: Users can view their own quizzes and public ones
CREATE POLICY "Users can view own quizzes"
  ON quizzes FOR SELECT
  USING (creator_id = auth.uid());

-- Policy: Users can create quizzes
CREATE POLICY "Users can create quizzes"
  ON quizzes FOR INSERT
  WITH CHECK (creator_id = auth.uid());

-- Policy: Users can update own quizzes
CREATE POLICY "Users can update own quizzes"
  ON quizzes FOR UPDATE
  USING (creator_id = auth.uid());

-- Updated at trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_quizzes_updated_at
  BEFORE UPDATE ON quizzes
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

## Logging Standards

### Structured Logging with Bunyan
```typescript
// apps/backend/src/config/logger.ts
import { createLogger, LogLevel } from 'bunyan';

export const logger = createLogger({
  name: 'quizforge-backend',
  level: (process.env.LOG_LEVEL as LogLevel) || 'info',
  serializers: {
    err: (err: Error) => ({
      message: err.message,
      stack: err.stack,
      name: err.name,
    }),
  },
});

// Usage
logger.info({ quizId: '123', userId: '456' }, 'Quiz created successfully');
logger.warn({ pin: 'ABC123' }, 'Max players reached');
logger.error({ err: error }, 'Failed to process answer');
```

## Performance Monitoring & Metrics

### Key Metrics to Track
```typescript
// apps/backend/src/config/metrics.ts
export const metrics = {
  // TODO: Replace with proper metrics solution (Prometheus, Datadog)
  connections: 0,
  activeGames: 0,
  totalAnswers: 0,
  
  incrementConnections(): void {
    this.connections++;
  },
  
  decrementConnections(): void {
    this.connections--;
  },
  
  recordAnswer(): void {
    this.totalAnswers++;
  },
  
  getStats() {
    return {
      connections: this.connections,
      activeGames: this.activeGames,
      totalAnswers: this.totalAnswers,
      memory: process.memoryUsage(),
    };
  }
};

// Expose metrics endpoint
app.get('/metrics', (req, res) => {
  res.json(metrics.getStats());
});
```

## Error Handling & Edge Cases

### Game Session Edge Cases
```typescript
// apps/backend/src/game/engine/edge-cases.ts

/**
 * Handle late join (player joins mid-game)
 */
export async function handleLateJoin(session: GameSession, player: Player): Promise<void> {
  // Send current question immediately if game is in progress
  if (session.status === 'playing' && session.currentQuestion) {
    player.socket.emit('question', session.currentQuestion);
  }
  
  // Send current leaderboard
  player.socket.emit('game-state', {
    players: session.getLeaderboard(),
    currentQuestionIndex: session.currentQuestionIndex,
  });
  
  // Mark as late joiner for scoring adjustments
  player.isLateJoiner = true;
  
  logger.game('Player late-joined', { pin: session.pin, username: player.username });
}

/**
 * Handle player disconnect (graceful vs timeout)
 */
export function handleDisconnect(socket: Socket, reason: string): void {
  const session = SessionManager.findBySocketId(socket.id);
  if (!session) return;

  const player = session.getPlayer(socket.id);
  if (!player) return;

  // Set disconnected state
  player.status = 'disconnected';
  player.disconnectedAt = Date.now();

  // Notify other players
  socket.to(session.pin).emit('player-left', { playerId: socket.id });

  // If host disconnects, end session
  if (player.isHost) {
    session.end('Host disconnected');
    logger.game('Session ended: host disconnected', { pin: session.pin });
  }

  // Auto-remove after 5 minutes
  setTimeout(() => {
    if (player.status === 'disconnected') {
      session.removePlayer(player.id);
    }
  }, 5 * 60 * 1000);
}

/**
 * Prevent duplicate username
 */
export async function isUsernameAvailable(pin: string, username: string): Promise<boolean> {
  const result = await withUnit(true, async (unit) => {
    return await unit.prepare<{ count: number }>(`
      SELECT COUNT(*) as count FROM session_players sp
      JOIN sessions s ON sp.session_id = s.id
      WHERE s.pin = $pin AND sp.username = $username
    `).get({ pin, username });
  });

  return result!.count === 0;
}
```

## Deployment & Environment

### Environment Validation
```typescript
// apps/backend/src/config/environment.ts
import { z } from 'zod';

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'test', 'production']).default('development'),
  PORT: z.string().regex(/^\d+$/).transform(Number).default('3000'),
  POSTGRES_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
  FRONTEND_URL: z.string().url(),
  LOG_LEVEL: z.enum(['trace', 'debug', 'info', 'warn', 'error', 'fatal']).default('info'),
});

const parsed = envSchema.safeParse(process.env);

if (!parsed.success) {
  console.error('Environment validation failed:', parsed.error.errors);
  process.exit(1);
}

export const config = parsed.data;
```

### .env.example
```bash
# apps/backend/.env.example
NODE_ENV=development
PORT=3000
POSTGRES_URL=postgres://user:password@localhost:5432/quizforge
JWT_SECRET=your-super-secret-jwt-key-min-32-chars-long
FRONTEND_URL=http://localhost:4200
LOG_LEVEL=info
```

## Common Pitfalls to Avoid
- ❌ **Don't** forget to call `unit.complete()` - causes connection pool exhaustion
- ❌ **Don't** use synchronous database calls in WebSocket handlers (blocks event loop)
- ❌ **Don't** store sensitive data in Socket.IO handshake or client-side
- ❌ **Don't** trust client-side timestamps - always use server time
- ❌ **Don't** emit to entire `io` when `socket.to(room)` is sufficient
- ❌ **Don't** use `console.log` in production - use structured logger
- ❌ **Don't** ignore WebSocket errors - always handle disconnections
- ✅ **Do** use transactions for multi-step database operations
- ✅ **Do** implement idempotency keys for answer submissions (prevent double-submit)
- ✅ **Do** close database connections in finally blocks
- ✅ **Do** use prepared statements for ALL queries
- ✅ **Do** log game events separately for analytics
- ✅ **Do** validate ALL WebSocket messages with Zod schemas

## TODO: Backend Unknowns
- [ ] ORM/Query Builder selection (drizzle-orm vs kysely vs raw `bun:postgres`)
- [ ] Redis integration for distributed rate limiting and session storage
- [ ] BullMQ or similar for background jobs (analytics processing, cleanup)
- [ ] File upload handling for image-based questions (Multer alternative for Bun)
- [ ] WebSocket clustering for horizontal scaling (Redis adapter)
- [ ] API response caching strategy (Redis)
- [ ] Compression middleware for large payloads (zlib)
- [ ] Supabase Auth integration vs custom JWT
- [ ] Database backup automation
- [ ] Monitoring & alerting setup (Sentry, DataDog)
```
